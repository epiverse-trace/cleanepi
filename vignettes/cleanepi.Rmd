---
title: "Introduction to cleanepi"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to cleanepi}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE} 
knitr::opts_chunk[["set"]](collapse = TRUE, comment = "#>", eval = FALSE,
                           fig.width = 7L, fig.height = 7L,
                           fig.align = "center")
row_id <- group_id <- NULL
```


# An overview

Data cleaning is a critical step of data analysis, especially considering the messy nature of real-world data, which often includes duplicates, errors, incomplete entries, and irrelevant formats. Addressing these issues is essential for producing accurate, reliable, and reproducible results. However, data cleaning can pose a substantial barrier in data analysis due to the time-consuming nature of the process.

**{cleanepi}** is an R package designed specifically to address this challenge by offering tools to clean, curate, and standardize datasets. Tailored specifically for epidemiological data and compatible with data frame-like structures, **{cleanepi}** offers a suite of functions designed to streamline common data cleaning tasks.

This vignette provides a comprehensive guide to the functionalities encapsulated within **{cleanepi}**. It provides users with detailed insights into each function's purpose and practical usage, equipping them with the tools necessary to navigate and manipulate cluttered datasets effectively.

```{r setup, eval=TRUE}
library("cleanepi")
```

# General data cleaning tasks

The main function in **{cleanepi}** is `clean_data()` that can perform the following tasks:

1. Scan the input data to determine the percent of missing, numeric, character, logical and date values in every column of the input data frame.
2. Clean up column names and convert them to more intuitive formats. This includes many sub-tasks such as replacing a space, dot, or hyphen between two words with underscore; converting camel-cases to snake-cases; substituting foreign characters with their corresponding English characters; and splitting a long word into multiple short words by capital characters within, if any, and connecting them with underscores.   
3. Find and remove duplicated rows across all columns or some specific columns.
4. Remove empty rows and columns as well as constant columns, i.e. columns with the same value across all rows.   
5. Replace missing entries with `NA`. 
6. Check whether the sequence of date events are correct in all rows of the input data.
7. Convert `character` columns into `Date` if the column actually contains values of type `Date` to some extent (default is at least 60% of the values are `Date`).
8. Detect and remove rows with subject IDs that do not comply with the expected format.
9. Perform dictionary-based cleaning: replace keys in specific columns with their corresponding values stored in a data dictionary file, and replace misspelled values with their correct ones.
10. Convert numbers written in characters into numeric.
11. Calculate the time span between columns or values of type Date.
12. Convert numeric values into Date.
13. Print the data cleaning report.


```{r eval=TRUE, comment=""}
# IMPORTING THE TEST DATASET
test_data <- readRDS(system.file("extdata", "test_df.RDS",
                                 package = "cleanepi"))
```

```{r eval=TRUE, echo=FALSE}
test_data |>
  kableExtra::kbl() |>
  kableExtra::kable_paper("striped", font_size = 14, full_width = TRUE) |>
  kableExtra::scroll_box(height = "200px", width = "100%",
                         box_css = "border: 1px solid #ddd; padding: 5px; ",
                         extra_css = NULL,
                         fixed_thead = TRUE)
```

```{r eval=TRUE, comment=""}
# SCAN THE DATA
scan_result <- scan_data(test_data)
```

```{r eval=TRUE, echo=FALSE}
scan_result |>
  kableExtra::kbl() |>
  kableExtra::kable_paper("striped", font_size = 14, full_width = FALSE) |>
  kableExtra::scroll_box(height = "200px", width = "100%",
                         box_css = "border: 1px solid #ddd; padding: 5px; ",
                         extra_css = NULL,
                         fixed_thead = TRUE)
```

In **{cleanepi}**, every cleaning operation is encapsulated within a module, with detailed descriptions provided in the package design vignette. Each module also specifies the parameters required for its main function, outlined in the sections below.

In the following chunk, we define a list of cleaning operations that we want to perform on the input data.

```{r eval=TRUE, comment=""}
# PARAMETERS FOR REPLACING MISSING VALUES WITH NA
rm_na <- list(target_columns = NULL, na_strings = "-99")

# PARAMETERS FOR COLUMN NAMES STANDARDIZATION
standardize_col_names <- list(keep = NULL, rename = NULL)

# PARAMETERS FOR DUBLICATES DETECTION AND REMOVAL
rm_dup <- list(target_columns   = NULL)

# PARAMETERS FOR STANDARDING DATES
stdn_date <- list(target_columns  = NULL,
                  error_tolerance = 0.4,
                  format          = NULL,
                  timeframe       = as.Date(c("1973-05-29", "2023-05-29")),
                  orders          = list(world_named_months = c("Ybd", "dby"),
                                         world_digit_months = c("dmy", "Ymd"),
                                         US_formats       = c("Omdy", "YOmd")),
                  modern_excel    = TRUE)

# PARAMETERS FOR STANDARDING SUBJECT IDs
stdn_ids <- list(target_columns = "study_id",
                 prefix         = "PS",
                 suffix         = "P2",
                 range          = c(1, 100),
                 nchar          = 7)

# PARAMETERS FOR CONSTANT COLUMNS, EMPTY ROWS AND COLUMNS REMOVAL
remove_cte <- list(cutoff = 1)

# LAOD THE DATA DICTIONARY
test_dictionary <- readRDS(system.file("extdata", "test_dictionary.RDS",
                                       package = "cleanepi"))

# DEFINE THE LIST OF PARAMETERS
params <- list(
  standardize_column_names = standardize_col_names,
  remove_constants         = remove_cte,
  replace_missing_values   = rm_na,
  remove_duplicates        = rm_dup,
  standardize_dates        = stdn_date,
  standardize_subject_ids  = stdn_ids,
  dictionary               = test_dictionary
)
```

The `clean_data()` function, as shown below, requires 2 arguments:

1. **data**: A `data.frame` or `linelist`.
2. **params**: A list of parameters that define the cleaning operations to
    be performed.

```{r eval=TRUE, comment=""}
# CLEAN THE INPUT DATA FRAME
cleaned_data <- clean_data(
  data   = test_data,
  params = params
)
```

It returns the cleaned dataset. The report generated from the data cleaning operations is a `list object` that is attached to the cleaned data and can be accessed using the `attr()` function. The report contains details of each cleaning operation that was performed during the process. However, users can access the report using the code below:

```{r eval=TRUE}
# ACCESS THE DATA CLEANING REPORT
report <- attr(cleaned_data, "report")

# SUMMARIZE THE REPORT OBJECT
summary(report)
```

The report can also be displayed in an HTML format using the `print_report()` function as shown below:

```{r eval=FALSE}
print_report(report)
```


# Specific data cleaning tasks

**{cleanepi}** luckily provides users with the flexibility to call a specific function if they wish to perform that particular task individually. This approach allows users to have more control over the data cleaning process and to apply additional data cleaning functions as needed.

For example, some data cleaning operations, such as renaming columns, removing empty rows and columns, removing columns with the same values across all rows, and standardizing date columns, play a central role in standardizing the epidemiological data. These operations can be performed within the framework of the `clean_data()` function or alone by calling the relevant function.

This setup offers users both convenience and flexibility, as they can perform all the cleaning operations at once, or execute them individually according to their specific needs.


## Remove constant data

Some datasets contain constant columns (columns with the same values across all rows), and/or empty rows and columns (rows or columns where all values are missing i.e `NA`).
The `remove_constants()` function can be used to remove such “noise”. The function takes the following argument:

1. **data**: the input data frame or linelist,
2. **cutoff**: a numeric, between `0` and `1`, to be used when removing empty rows and columns. When provided, only rows and columns where the percent of missing data is greater than this cut-off will removed. Rows and columns with 100% missing values will be remove by default.

```{r echo=FALSE, eval=TRUE}
# IMPORT THE INPUT DATA
data <- readRDS(system.file("extdata", "test_df.RDS", package = "cleanepi"))

# INTRODUCE AN EMPTY COLUMN
data$empty_column <- NA

# remove the constant columns, empty rows and columns
dat <- remove_constants(data   = data,
                        cutoff = 1)
```

```{r echo=FALSE, eval=TRUE}
dat |>
  kableExtra::kbl() |>
  kableExtra::kable_paper("striped", font_size = 14, full_width = TRUE) |>
  kableExtra::scroll_box(height = "200px", width = "100%",
                         box_css = "border: 1px solid #ddd; padding: 5px; ",
                         extra_css = NULL,
                         fixed_thead = TRUE)
```

The `remove_constants()` function returns a dataset where all constant columns, empty rows and columns are removed.


## Cleaning column names

The syntax used to name the columns of a dataset during its creation depending on many factors such as the language, the naming convention, etc.
We provide, in **{cleanepi}**, the `standardize_column_names()` function to clean up column names and convert them to more intuitive formats. It performs many sub-tasks including: replacing a space, dot, or hyphen between two words with underscore; converting camel-cases to snake-cases; substituting foreign characters with their corresponding English characters; and splitting along word into multiple short words by capital characters within, if any, and 
connecting them with underscores. The function can take the following arguments:

1. **data**: the input data frame or linelist
2. **keep**: a vector of column names to maintain as they are. When dealing with a linelist, this can be set to `linelist_tags`, to maintain the tagged column names. The Default is `NULL`.
3. **rename**: an expression used to specify how to rename some columns.

```{r eval=TRUE, comment="col_name_cleaning"}
# IMPORT AND PRINT THE INITAL COLUMN NAMES
data <- readRDS(system.file("extdata", "test_df.RDS", package = "cleanepi"))
print(colnames(data))

# KEEP 'date.of.admission' AS IS
cleaned_data <- standardize_column_names(
  data = data,
  keep = "date.of.admission"
)
print(colnames(data))

# KEEP 'date.of.admission' AS IS, BUT RENAME 'dateOfBirth' AND 'sex' TO
# 'DOB' AND 'gender' RESPECTIVELY
cleaned_data <- standardize_column_names(
  data   = data,
  keep   = "date.of.admission",
  rename = c("DOB" = "dateOfBirth", "gender" = "sex")
)
print(colnames(data))
```

By providing the function with these parameters, the users can redefine the name of the columns and get easy to work with column names. This enables a more comprehensive naming system that is tailored to the needs of the user.


## Replacing missing entries with `NA`

It is common to have missing values in an input dataset. By default, R expects missing values to be represented by `NA`, However, this is not always the case as some dataset can contain a specific character string that denotes the missing value. In the presence of such a scenario, user can call the `replace_missing_values()` function to substitute these missing values with `NA`. This will make the data suitable for any data science operations. The function takes the following arguments:

1. **data**: the input data frame or linelist.
2. **target_columns**: a vector of column names. If provided, the substitution of missing values will only be executed in those specified columns. When the input data is a `linelist` object, this parameter can be set to `linelist_tags` if you wish to replace missing values with `NA` on tagged columns only. The default value `NULL` i.e. replace missing values across all columns.
3. **na_strings**: a vector of character strings that represents the missing values in the columns of interest. By default, it utilizes `cleanepi::common_na_strings`. However, if the missing values string in the columns of interest is not included in this predefined vector, it can be used as the value for this argument.

```{r eval=TRUE, comment="default_missing_values"}
# VISUALIZE THE PREDEFINED VECTOR OF MISSING CHARACTERS
print(cleanepi::common_na_strings)
```

```{r eval=TRUE, comment="replace_missing"}
# REPLACE ALL OCCURENCES OF "-99" WITH NA IN THE "sex" COLUMN
cleaned_data <- replace_missing_values(
  data           = readRDS(system.file("extdata", "test_df.RDS",
                                       package = "cleanepi")),
  target_columns = "sex",
  na_strings     = "-99"
)

# REPLACE ALL OCCURENCES OF "-99" WITH NA FROM ALL COLUMNS
cleaned_data <- replace_missing_values(
  data           = readRDS(system.file("extdata", "test_df.RDS",
                                       package = "cleanepi")),
  target_columns = NULL,
  na_strings     = "-99"
)
```

```{r echo=FALSE, eval=TRUE}
cleaned_data |>
  kableExtra::kbl() |>
  kableExtra::kable_paper("striped", font_size = 14, full_width = TRUE) |>
  kableExtra::scroll_box(height = "200px", width = "100%",
                         box_css = "border: 1px solid #ddd; padding: 5px; ",
                         extra_css = NULL,
                         fixed_thead = TRUE)
```


## Standardizing Dates

The default date format in R is `Ymd` (the ISO8601 format). However, it is very common to encounter date values that are written differently from this. Also, there are cases where a column in a data frame contains both values of type `Date`, `character` or others.   

The `standardize_dates()` function provides a comprehensive set of options for converting date columns into a specified format and handling various scenarios, such as different date formats and mixed data types in a column.

Entries which cannot be processed result in `NA`. An error threshold can be used to define the maximum number of resulting `NA` (i.e. entries without an identified date) that can be tolerated. If this threshold is exceeded, the original vector is returned.

The function expects the following arguments:

1. **data**: A data frame or linelist  (required).   
2. **target_columns**: A vector of the names of the columns to be converted (optional). When not provided, the function will attempt to detect date columns and perform the  conversion if needed.
3. **format**: A format of the values in the specified columns (optional). If not provided, the function will attempt to infer the format.
4. **timeframe**: The expected time frame within which the date values should fall. Values  outside of this range will be set to `NA` (optional).
5. **error_tolerance**: The maximum percentage of `NA` values (non date values) that can be allowed in a converted column. Default is 40% i.e. `0.4`.
6. **orders**: The date codes for fine-grained parsing of dates. It is used for parsing of mixed dates. If a list is supplied, that list will be used for successive tries in parsing. Default is:

```{r}
orders <- list(
  world_named_months = c("Ybd", "dby"),
  world_digit_months = c("dmy", "Ymd"),
  US_formats         = c("Omdy", "YOmd")
)
```

7. **modern_excel**: A Boolean that determines whether all numeric values represent dates from either a Windows version of Excel or a 2011 or later version of Excel for OSX. Set this parameter to `FALSE` if the data came from an OSX version of Excel before 2011. This is only relevant when parsing dates from excel. Default is `TRUE`.

> ⚠️ The `error_tolerance` must be used with caution. When it is set, and the percentage of non-date values (NA i.e. values that were not converted into date) in a character column is greater than this threshold, the column will be returned as it is.

> The value for the `orders` argument can be modified to suit the user's needs. Other date formats can be specified too. For instance, if you want to prioritize American-style dates with numeric months, you can switch the second and third elements of the default orders as shown below:

```{r eval=FALSE}
# GIVE PRIORITY TO AMERICAN-STYLE DATES
us_ord <- orders[c(1L, 3L, 2L)]

# ADD A FORMAT WITH HOURS TO THE EXISTING orders
# THIS WILL ALLOW FOR THE CONVERSION OF VALUES SUCH AS "2014_04_05_23:15:43"
# WHEN THEY APPEAR IN THE TARGET COLUMNS.
orders$ymdhms <- c("Ymdhms", "Ymdhm")
```

This function provides users with the flexibility to standardize date columns in their dataset according to specified requirements, including format, timeframe, and error tolerance for conversion from character to date columns.

```{r eval=TRUE, comment="date_standardisation"}
# STANDARDIZE VALUES IN THE 'date_first_pcr_positive_test' COLUMN
test_data <- readRDS(system.file("extdata", "test_df.RDS",
                                 package = "cleanepi"))

head(test_data$date_first_pcr_positive_test)

res <- standardize_dates(
  data            = test_data,
  target_columns  = "date_first_pcr_positive_test",
  format          = NULL,
  timeframe       = NULL,
  error_tolerance = 0.4,
  orders          = list(world_named_months = c("Ybd", "dby"),
                         world_digit_months = c("dmy", "Ymd"),
                         US_formats         = c("Omdy", "YOmd")),
  modern_excel    = TRUE
)
```

This function returns the input dataset where the (specified) columns are converted into Date if the condition is met.

```{r echo=FALSE, eval=TRUE}
res |>
  kableExtra::kbl() |>
  kableExtra::kable_paper("striped", font_size = 14, full_width = TRUE) |>
  kableExtra::scroll_box(height = "200px", width = "100%",
                         box_css = "border: 1px solid #ddd; padding: 5px; ",
                         extra_css = NULL,
                         fixed_thead = TRUE)
```


## Standardizing subject IDs

### Detecting and remove incorrect subject ids

The `check_subject_ids()` function is designed to identify rows from the input dataset where the ids don't comply with the expected subject ids format. It expects the following parameters:

1. **data**: A data frame or linelist (required).
2. **target_columns**: The name of the column containing the subject IDs in the dataset (required).
3. **nchar**: The expected number of character in the subject ids (optional).
4. **prefix**: A string. If subject IDs have a specific prefix, it is used as a value for this argument. This is optional and can be omitted if there is no prefix.
5. **suffix**: A string. If subject IDs have a specific suffix, it is used as a value for this argument. It can be ignored otherwise.
6. **range**: A vector of two elements. If there is an expected range of numbers within the subject IDs, define it using  this parameter. It is optional and can be omitted if there is no specific range.
7. **remove**: A logical that determines whether to remove the incorrect subject IDs or not. By default, the wrong ids are detected and reported. To replace these, use the `correct_subject_ids()` function described below.

By providing these parameters, the function becomes a versatile tool for data cleaning, ensuring that the user is alerted on the presence of unexpected, missing and duplicated subject ids. When using the function, make sure to tailor the parameters according to the specific requirements of your dataset and the expected characteristics of the subject IDs.

```{r eval=TRUE, comment="subject_ids_standardisation"}
# DETECT AND REMOVE INCORRECT SUBJECT IDs
res <- check_subject_ids(
  data           = readRDS(system.file("extdata", "test_df.RDS",
                                       package = "cleanepi")),
  target_columns = "study_id",
  prefix         = "PS",
  suffix         = "P2",
  range          = c(1L, 100L),
  nchar          = 7L
)

# EXTRACT REPORT
report <- attr(res, "report")

# SUMMARIZE THE REPORT OBJECT
summary(report)
```

The `check_subject_ids()` function returns the input dataset and send a warming when there are some incorrect ids.

In addition to detecting undesirable subject ids, the function will also look for missing and duplicated IDs. As the result of this, the report made from this operation might contain two extra elements: **missing_ids** (a vector of row indexes where there is a missing IDs) and **duplicated_ids** (a data frame of rows with the duplicated IDs). Use the `print_report()` function to display the report made from this operation.


### Correct wrong subject ids

After the detection of the incorrect subject ids using the `check_subject_ids()`, use the `correct_subject_ids()` to replace non complying ids with the correct ones. The function requires a data frame with the following two columns:

1. **from**: a column with the incorrect subject ids,
2. **to**: a column with the values to be used to substitute the incorrect ids.

```{r eval=TRUE, comment="correct ids"}
# IMPORT THE INPUT DATA
data <- readRDS(system.file("extdata", "test_df.RDS", package = "cleanepi"))

# GENERATE THE CORRECTION TABLE
correction_table <- data.frame(
  from = c("P0005P2", "PB500P2", "PS004P2-1"),
  to   = c("PB005P2", "PB050P2", "PS004P2"),
  stringsAsFactors = FALSE
)

# PERFORM THE CORRECTION
dat <- correct_subject_ids(
  data             = data,
  target_columns   = "study_id",
  correction_table = correction_table
)
```


## Checking date sequence

The `check_date_sequence()` function verifies the order of sequences in date event columns within a dataset. It ensures that the values in the specified date columns follow the desired chronological order. Here are the arguments accepted by the function:

1. **data**: A data frame or linelist (required).
2. **target_columns**: A vector containing the names of the date columns of interest. These columns should be listed in the expected order of occurrence, reflecting the chronological sequence of events. For example, `target_columns = c("date_of_infection", "date_of_admission", "date_of_death")`.

By utilizing these arguments, the `check_date_sequence()` function facilitates the validation of date sequences within a dataset, ensuring data integrity and accuracy for further analysis. Additionally, it offers flexibility by allowing users to choose whether to remove rows with incorrect sequences or store them for further examination in the report object.

```{r eval=TRUE, comment="check_date_order"}
# DETECT ROWS WITH INCORRECT DATE SEQUENCE
res <- check_date_sequence(
  data           = readRDS(system.file("extdata", "test_df.RDS",
                                       package = "cleanepi")),
  target_columns = c("date_first_pcr_positive_test", "date.of.admission")
)

# EXTRACT THE REPORT
report <- attr(res, "report")

# SUMMARIZE THE REPORT OBJECT
summary(report)
```

The `check_date_sequence()` function returns the input dataset, augmented with an attributes named as `incorrect_date_sequence` if there are rows with incorrect date sequences.
This attribute highlights any discrepancies found in the date sequences, enabling users to take appropriate actions. Use the `print_report()` function to display the report made from this operation.

## Converting character columns into numeric

In certain scenarios, the input data contains columns where the number are written in letters. For instance, the ages of a study participants can be written in letters. Similarly, a column can contain values written in both numbers and letters (an age column where some values are written in numbers and others in letters). The `convert_to_numeric()` function offers the framework to convert all numbers written in letters from a given column into numeric. It takes the following arguments:

1. **data**: A data frame or linelist (required).
2. **target_columns**: A vector containing the names of the columns of interest. When dealing with a linelist, this can be set to `linelist_tags` if the tagged columns are the one to be converted into numeric. When `target_columns = NULL`, the function uses the output form the `scan_data()` function to identify the columns where the proportion of numeric values is at least twice as the percentage of character values. Those columns will be the columns of interest and the character values in them will be converted into numeric. 
Note that any string in such column that can not be converted into numeric will be set to `NA` in the resulting data.
3. **lang**: A character string with language to be used when performing the conversion. Currently one of `"en", "fr", or "es"`.

```{r eval=TRUE, comment="check_date_order"}
# CONVERT THE 'age' COLUMN IN THE TEST LINELIST DATA
dat <- readRDS(system.file("extdata", "messy_data.RDS", package = "cleanepi"))
head(dat$age, 10L)
dat <- convert_to_numeric(dat, target_columns = "age", lang = "en")
head(dat$age, 10L)
```


## Converting numeric values into date

Some columns in a data frame might contain numeric values that represents the number of days elapsed between two events. For instance, the recruitment day of individuals in a study can be stored as a numeric column where the numeric values are the count of days between when they are recruited and when there were admitted in the hospital. The actual dates when the individuals were recruited can be retrieved using the `convert_numeric_to_date()` function.
This function can take the following parameters:

1. **data**: the input data frame or linelist.
2. **target_columns**: a vector or a comma-separated list of columns names to be converted from numeric to date. When the input data is a `linelist` object, this parameter can be set to `linelist_tags` if tagged variables are the target columns.
3. **ref_date**: a reference date
4. **forward**: a Boolean that indicates whether the counts started after the reference date (`TRUE`) or not (`FALSE`). The default is `TRUE`.

```{reval=TRUE, comment="convert_numeric_to_date"}
data <- readRDS(system.file("extdata", "test_df.RDS", package = "cleanepi")) |>
  standardize_dates(target_columns = "date.of.admission")

# CREATE THE RECRUITMENT DATE COLUMNS
data$recruitment_date <- sample(20:50, nrow(data), replace = FALSE)

# RETRIVE THE DATE INDIVIDUALS WERE RECRUITED
data <- convert_numeric_to_date(
  data           = data,
  target_columns = "recruitment_date",
  ref_date       = "date.of.admission",
  forward        = TRUE
)

# RETRIVE THE DATE INDIVIDUALS WERE RECRUITED
data <- convert_numeric_to_date(
  data           = data,
  target_columns = "recruitment_date",
  ref_date       = as.Date("2019-10-13"),
  forward        = FALSE
)
```

The function returns the input data where the values in the target columns(s) are converted into Date. This enables the usage of **{cleanepi}'s** functions that operates on Date columns as well as the powerful functions that can be used to manipulate Dates from the {base} R or {lubridate} packages.



## Finding duplicated rows

The `find_duplicates()` function serves the purpose of identifying duplicated rows within a given dataset. It accepts the following parameters:

1. **data**: The input data frame or linelist.
2. **target_columns**: A vector containing either column names or column indices from which  duplicated rows will be identified. If `NULL` is passed, duplicates will be detected  across all columns of the dataset. Notably, if the input dataset is a `linelist` object, `target_columns` can be set to `linelist_tags` specifically to identify duplicates across the tagged variables only. 

By leveraging the `find_duplicates()` function with appropriate parameters, users can efficiently pinpoint duplicated rows within their datasets, either across all columns or selectively across tagged variables in a `linelist` object.

```{r eval=TRUE, comment=""}
# IMPORT A `linelist` DATA
data <- readRDS(system.file("extdata", "test_linelist.RDS",
                            package = "cleanepi"))

# SHOW THE TAGGED VARIABLES
linelist::tags(data)

# FIND DUPLICATES ACROSS ALL COLUMNS EXCEPT THE SUBJECT IDs COLUMN
all_columns    <- names(data)
target_columns <- all_columns[all_columns != "id"]
dups           <- find_duplicates(data           = data,
                                  target_columns = target_columns)

# FIND DUPLICATES ACROSS TAGGED VARIABLES
dups <- find_duplicates(
  data           = data,
  target_columns = "linelist_tags"
)
```

Upon execution, the `find_duplicates()` function identifies all duplicated rows either based on all columns or those specified, and stores them in the report. In addition to the existing columns, it appends two extra columns to the dataset:

1. `row_id`: Contains indexes of the duplicated rows from the original input dataset.
2. `group_id`: Contains unique identifiers assigned to each duplicated group, which is defined as a set of rows sharing identical values in the designated columns of interest.

By including these extra columns, users gain insights into the specific rows identified as duplicates and their corresponding group identifiers, enabling efficient analysis and management of duplicated data within the dataset.

```{r eval=TRUE}
# VISUALIZE THE DUPLICATES
report     <- attr(dups, "report")
duplicates <- report$duplicated_rows
duplicates |>
  kableExtra::kbl() |>
  kableExtra::kable_paper("striped", font_size = 14, full_width = FALSE) |>
  kableExtra::scroll_box(height = "200px", width = "100%",
                         box_css = "border: 1px solid #ddd; padding: 5px; ",
                         extra_css = NULL,
                         fixed_thead = TRUE)
```

## Removing duplicates

To eliminate duplicated rows from a dataset, the `remove_duplicates()` function can be employed. This function internally utilizes the `find_duplicates()` function and expects the following parameters:

1. **data**: A data frame or linelist from which duplicated rows will be removed.
2. **target_columns**: A vector containing either column names or indices specifying the  columns from which duplicated rows will be identified. If set to `NULL`, the function will detect duplicates across all columns. If the input dataset is a `linelist` object, setting this parameter to `linelist_tags` will identify duplicates across the tagged variables only.
3. **remove**: A numeric vector of the indices of the duplicated rows to be removed. If set to  `NULL`, the function removes duplicates and retains only the first occurrence of the   duplicated rows.

```{r eval=TRUE}
# REMOVE DUPLICATE ACROSS TAGGED COLUMNS ONLY.
res <- remove_duplicates(
  data           = readRDS(system.file("extdata", "test_linelist.RDS",
                                       package = "cleanepi")),
  target_columns = "linelist_tags",
  remove         = NULL
)
```

Upon execution, the `remove_duplicates()` function returns the input dataset without duplicated rows removed (if found).
The details about the duplicates removal operation are stored in the report object that is attached to the output object. When duplicates are found, this report will contain the following elements:

- **duplicated_rows**: A data frame with the detected duplicates.
- **removed_duplicates**: A data frame with the duplicated rows that have been removed.
- **duplicates_checked_from**: A vector of column names from which duplicates were identified.

By examining these elements within the report, users gain insights into the specific duplicated rows, those that were removed, and the columns used to identify the duplicates, thus facilitating transparency and documentation of the duplicates removal process.

```{r eval=TRUE, comment=""}
# ACCESS THE REPORT
report <- attr(res, "report")

# SUMMARIZE THE REPORT OBJECT
summary(report)
```

Use the `print_report()` function to display the report made from this operation.

The output from `find_duplicates()` function can also be passed to `remove_duplicates()` function to specify which duplicated rows to be removed.  

```{r eval=TRUE, comment="find_and_remove_dups"}
# DETECT DUPLICATES FROM TAGGED COLUMNS
dups <- find_duplicates(
  data           = readRDS(system.file("extdata", "test_linelist.RDS",
                                       package = "cleanepi")),
  target_columns = "linelist_tags"
)

# EXTRACT THE DUPLICATES
report     <- attr(dups, "report")
duplicates <- report$duplicated_rows

# REMOVE FIRST OCCURRENCE OF DUPLICATED ROWS
dups_index_to_remove <- duplicates[["row_id"]][seq(1L, nrow(dups), 2L)]
dups_index_to_remove <- dups_index_to_remove[!is.na(dups_index_to_remove)]
no_dups <- remove_duplicates(
  data           = readRDS(system.file("extdata", "test_linelist.RDS",
                                       package = "cleanepi")),
  target_columns = "linelist_tags",
  remove         = dups_index_to_remove
)

# KEEP SPECIFIC DUPLICATED ROWS
no_dups <- remove_duplicates(
  data           = readRDS(system.file("extdata", "test_linelist.RDS",
                                       package = "cleanepi")),
  target_columns = "linelist_tags",
  remove         = -c(33, 55)
)
```

## Dictionary based data substituting

The `clean_using_dictionary()` function offers a convenient way to replace the options in a data frame or linelist with their corresponding values stored in a data dictionary. The function expects the following arguments:

1. **data**: The input data frame or linelist that contains the options to be replaced.
2. **dictionary**: The data frame with the data dictionary that contains the complete labels for these options. The structure of this data dictionary file should adhere to the standards expected by the [matchmaker](https://www.repidemicsconsortium.org/matchmaker/)  package, as the `clean_using_dictionary()` function relies on functions from this   package.

```{r eval=TRUE, echo=FALSE}
test_dictionary |>
  kableExtra::kbl() |>
  kableExtra::kable_paper("striped", font_size = 14, full_width = TRUE)
```

The `add_to_dictionary()` function is a useful tool for expanding the coverage of a data dictionary by defining options that are present in the input data but not originally included in the dictionary. This function enables users to dynamically update the dictionary to accommodate new values encountered in the dataset. In addition to the current data dictionary the function takes the arguments defined below:

**option, value, grp, order**: the values for the options to be added in the data dictionary. The example below shows how this function is used.

By employing the `add_to_dictionary()` function, users can ensure that the data dictionary remains comprehensive and aligned with the evolving nature of the input dataset, thereby enhancing the accuracy and completeness of data interpretation and analysis. 
In the example below, we add `-99` to our test data dictionary, `test_dictionary`.

```{r eval=TRUE}
# READING IN THE DATA
data <- readRDS(system.file("extdata", "test_df.RDS",
                            package = "cleanepi"))

# ADD THE EXTRA OPTION TO THE DICTIONARY
test_dictionary <- add_to_dictionary(test_dictionary,
                                      option = "-99",
                                      value  = "unknow",
                                      grp    = "sex",
                                      order  = NULL)
```

```{r eval=TRUE, echo=FALSE}
test_dictionary |>
  kableExtra::kbl() |>
  kableExtra::kable_paper("striped", font_size = 14, full_width = TRUE)
```


```{r eval=TRUE, comment=""}
# PERFORM THE DICTIONARY-BASED SUBSTITUTION
cleaned_df <- clean_using_dictionary(
  data       = data,
  dictionary = test_dictionary
)
```

```{r eval=TRUE, echo=FALSE}
cleaned_df |>
  kableExtra::kbl() |>
  kableExtra::kable_paper("striped", font_size = 14, full_width = TRUE) |>
  kableExtra::scroll_box(height = "200px", width = "100%",
                         box_css = "border: 1px solid #ddd; padding: 5px; ",
                         extra_css = NULL,
                         fixed_thead = TRUE)
```

## Calculating time span in different time scales (“years”, “months”, “weeks”, or “days”)

The `span()` function computes the time span between two elements of type Date. The resulting time span can be expressed in “years”, “months”, “weeks”, or “days”, depending on the user-specified unit. The functions can take the following arguments:

1. **data**: The input dataset (required).
2. **target_column**: A string with the name of the target column (require). The values in this column are expected to be in the form of `Ymd` i.e. `2024-01-31`. The time span will calculated between these values and the `end_date` defined below.
3. **end_date**: it can be either a character that is the name of another column of type Date from the input data or a vector of Date values or a single Date value (required). This should also be in the ISO8601 format ("2024-01-31") and its default value is today's date `Sys.Date()`.
4. **span_unit**: This parameter determines the unit in which the time span is expressed (required). It can be calculated in “years”, “months”, “weeks”, or “days”. By default, the time span is calculated in “years” if this parameter is not provided.
5. **span_column_name**: A string for the name of the column added to the input data. The default is `span`.
6. **span_remainder_unit**: A parameter used to determine the unit in which the remainder of the time span calculation will be returned. The possible units are: “days” or “weeks” or “months”. By default, the function returns decimal age i.e. `span_remainder_unit = NULL`.

With these arguments, the function offers flexibility in determining the time span in different units. It facilitates various analytics tasks where the time span computation is a necessary component, providing users with the ability to customize the output according to their specific requirements.

```{r eval=TRUE}
# IMPORT DATA, REPLACE MISSING VALUES WITH 'NA' & STANDARDIZE DATES
data <- readRDS(system.file("extdata", "test_df.RDS", package = "cleanepi")) |>
  replace_missing_values(target_columns = "dateOfBirth",
                         na_strings     = "-99") |>
  standardize_dates(target_columns  = "dateOfBirth",
                    error_tolerance = 0.0)

# CALCULATE INDIVIDUAL AGE IN YEARS FROM THE 'dateOfBirth' COLUMN AND SEND THE
# REMAINDER IN MONTHS
age <- span(
  data                = data,
  target_column       = "dateOfBirth",
  end_date            = Sys.Date(),
  span_unit           = "years",
  span_column_name    = "age_in_years",
  span_remainder_unit = "months"
)

# CALCULATE THE TIME SPAN IN YEARS BETWEEN INDIVIDUALS 'dateOfBirth' AND THE DAY
# THEY TESTED POSITIVE
data <- readRDS(system.file("extdata", "test_df.RDS", package = "cleanepi"))
time_span  <- data |>
  replace_missing_values(target_columns = "dateOfBirth",
                         na_strings     = "-99") |>
  standardize_dates(
    target_columns  = c("dateOfBirth", "date_first_pcr_positive_test"),
    error_tolerance = 0.0
  ) |>
  span(
    target_column       = "dateOfBirth",
    end_date            = "date_first_pcr_positive_test",
    span_unit           = "years",
    span_column_name    = "elapsed_time",
    span_remainder_unit = NULL
  )
```

The `span()` function augments the input dataset by adding one or two extra columns containing age-related information. These additional columns are as follows:

1. **Calculated time span in the specified scale**: Contains the calculated time span in the specified unit (“years”, “months”, “weeks”, or “days”).

2. **Remaining number of days**: Indicates the remaining number of “days” or “weeks” or “months” after calculating the time span, representing the fractional part of the time span calculation. This column is included if needed, and provides additional granularity in the time span representation.

```{r eval=TRUE, echo=FALSE}
# DISPLAY THE OUTPUT OBJECT
time_span |>
  kableExtra::kbl() |>
  kableExtra::kable_paper("striped", font_size = 14, full_width = TRUE) |>
  kableExtra::scroll_box(height = "200px", width = "100%",
                         box_css = "border: 1px solid #ddd; padding: 5px; ",
                         extra_css = NULL,
                         fixed_thead = TRUE)
```

## Printing the report

```{r echo=TRUE, eval=FALSE}
print_report(
  data             = data,
  report_title     = "{cleanepi} data cleaning report",
  output_directory = ".",
  output_filename  = "cleaning_report",
  format           = "html",
  print            = TRUE
)
```
